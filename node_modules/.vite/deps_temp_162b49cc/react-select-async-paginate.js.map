{
  "version": 3,
  "sources": ["../../@seznam/compose-react-refs/composeRefs.ts", "../../react-select-async-paginate/src/index.ts", "../../react-select-async-paginate/src/useAsyncPaginate.ts", "../../react-select-async-paginate/src/useAsyncPaginateBase.ts", "../../react-select-async-paginate/src/defaultReduceOptions.ts", "../../react-select-async-paginate/src/defaultShouldLoadMore.ts", "../../react-select-async-paginate/src/getInitialCache.ts", "../../react-select-async-paginate/src/getInitialOptionsCache.ts", "../../react-select-async-paginate/src/requestOptions.ts", "../../react-select-async-paginate/src/validateResponse.ts", "../../react-select-async-paginate/src/useComponents.ts", "../../react-select-async-paginate/src/wrapMenuList.tsx", "../../react-select-async-paginate/src/withAsyncPaginate.tsx", "../../react-select-async-paginate/src/reduceGroupedOptions.ts", "../../@vtaits/use-lazy-ref/src/index.ts", "../../use-is-mounted-ref/src/use-is-mounted-ref.ts", "../../use-latest/dist/use-latest.esm.js", "../../krustykrab/src/option_result.ts", "../../krustykrab/src/to_option.ts", "../../krustykrab/src/get_result.ts", "../../krustykrab/src/unwrap.ts", "../../krustykrab/src/unwrap_or.ts", "../../krustykrab/src/unwrap_or_else.ts", "../../krustykrab/src/try_catch.ts", "../../sleep-promise/build/esm.mjs"],
  "sourcesContent": ["import {MutableRefObject, Ref} from 'react'\n\ntype OptionalRef<T> = Ref<T> | undefined\n\nexport default function composeRefs<T>(...refs: [OptionalRef<T>, OptionalRef<T>, ...Array<OptionalRef<T>>]): Ref<T> {\n  if (refs.length === 2) { // micro-optimize the hot path\n    return composeTwoRefs(refs[0], refs[1]) || null\n  }\n\n  const composedRef = refs.slice(1).reduce(\n    (semiCombinedRef: OptionalRef<T>, refToInclude: OptionalRef<T>) => composeTwoRefs(semiCombinedRef, refToInclude),\n    refs[0],\n  )\n  return composedRef || null\n}\n\ntype NonNullRef<T> = NonNullable<Ref<T>>\nconst composedRefCache = new WeakMap<NonNullRef<unknown>, WeakMap<NonNullRef<unknown>, NonNullRef<unknown>>>()\n\nfunction composeTwoRefs<T>(ref1: OptionalRef<T>, ref2: OptionalRef<T>): OptionalRef<T> {\n  if (ref1 && ref2) {\n    const ref1Cache = composedRefCache.get(ref1) || new WeakMap<NonNullRef<unknown>, NonNullRef<unknown>>()\n    composedRefCache.set(ref1, ref1Cache)\n\n    const composedRef = ref1Cache.get(ref2) || ((instance: T): void => {\n      updateRef(ref1, instance)\n      updateRef(ref2, instance)\n    })\n    ref1Cache.set(ref2, composedRef)\n\n    return composedRef as NonNullRef<T>\n  }\n\n  if (!ref1) {\n    return ref2\n  } else {\n    return ref1\n  }\n}\n\nfunction updateRef<T>(ref: NonNullRef<T>, instance: null | T): void {\n  if (typeof ref === 'function') {\n    ref(instance)\n  } else {\n    (ref as MutableRefObject<T | null>).current = instance\n  }\n}\n", "import Select from \"react-select\";\nimport { withAsyncPaginate } from \"./withAsyncPaginate\";\n\nexport { wrapMenuList } from \"./wrapMenuList\";\nexport { reduceGroupedOptions } from \"./reduceGroupedOptions\";\n\nexport { withAsyncPaginate };\n\nexport {\n\tcheckIsResponse,\n\tvalidateResponse,\n} from \"./validateResponse\";\nexport { useAsyncPaginateBase } from \"./useAsyncPaginateBase\";\nexport { useAsyncPaginate } from \"./useAsyncPaginate\";\nexport { useComponents } from \"./useComponents\";\n\nexport const AsyncPaginate = withAsyncPaginate(Select);\n\nexport * from \"./types\";\n", "import { useCallback, useState } from \"react\";\nimport type { GroupBase, InputActionMeta } from \"react-select\";\nimport type {\n\tUseAsyncPaginateBaseResult,\n\tUseAsyncPaginateParams,\n\tUseAsyncPaginateResult,\n} from \"./types\";\nimport { useAsyncPaginateBase } from \"./useAsyncPaginateBase\";\n\nexport const useAsyncPaginate = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateParams<OptionType, Group, Additional>,\n\tdeps: ReadonlyArray<unknown> = [],\n): UseAsyncPaginateResult<OptionType, Group> => {\n\tconst {\n\t\tinputValue: inputValueParam,\n\t\tmenuIsOpen: menuIsOpenParam,\n\t\tdefaultInputValue: defaultInputValueParam,\n\t\tdefaultMenuIsOpen: defaultMenuIsOpenParam,\n\t\tonInputChange: onInputChangeParam,\n\t\tonMenuClose: onMenuCloseParam,\n\t\tonMenuOpen: onMenuOpenParam,\n\t} = params;\n\n\tconst [inputValueState, setInputValue] = useState(\n\t\tdefaultInputValueParam || \"\",\n\t);\n\tconst [menuIsOpenState, setMenuIsOpen] = useState(!!defaultMenuIsOpenParam);\n\n\tconst inputValue: string =\n\t\ttypeof inputValueParam === \"string\" ? inputValueParam : inputValueState;\n\n\tconst menuIsOpen: boolean =\n\t\ttypeof menuIsOpenParam === \"boolean\" ? menuIsOpenParam : menuIsOpenState;\n\n\tconst onInputChange = useCallback(\n\t\t(nextInputValue: string, actionMeta: InputActionMeta): void => {\n\t\t\tif (onInputChangeParam) {\n\t\t\t\tonInputChangeParam(nextInputValue, actionMeta);\n\t\t\t}\n\n\t\t\tsetInputValue(nextInputValue);\n\t\t},\n\t\t[onInputChangeParam],\n\t);\n\n\tconst onMenuClose = useCallback((): void => {\n\t\tif (onMenuCloseParam) {\n\t\t\tonMenuCloseParam();\n\t\t}\n\n\t\tsetMenuIsOpen(false);\n\t}, [onMenuCloseParam]);\n\n\tconst onMenuOpen = useCallback((): void => {\n\t\tif (onMenuOpenParam) {\n\t\t\tonMenuOpenParam();\n\t\t}\n\n\t\tsetMenuIsOpen(true);\n\t}, [onMenuOpenParam]);\n\n\tconst baseResult: UseAsyncPaginateBaseResult<OptionType, Group> =\n\t\tuseAsyncPaginateBase(\n\t\t\t{\n\t\t\t\t...params,\n\t\t\t\tinputValue,\n\t\t\t\tmenuIsOpen,\n\t\t\t},\n\t\t\tdeps,\n\t\t);\n\n\treturn {\n\t\t...baseResult,\n\t\tinputValue,\n\t\tmenuIsOpen,\n\t\tonInputChange,\n\t\tonMenuClose,\n\t\tonMenuOpen,\n\t};\n};\n", "import { useLazyRef } from \"@vtaits/use-lazy-ref\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { GroupBase } from \"react-select\";\nimport useIsMountedRef from \"use-is-mounted-ref\";\nimport useLatest from \"use-latest\";\nimport { defaultReduceOptions } from \"./defaultReduceOptions\";\nimport { defaultShouldLoadMore } from \"./defaultShouldLoadMore\";\nimport { getInitialCache } from \"./getInitialCache\";\nimport { getInitialOptionsCache } from \"./getInitialOptionsCache\";\nimport { requestOptions } from \"./requestOptions\";\nimport type {\n\tOptionsCacheItem,\n\tRequestOptionsCallerType,\n\tUseAsyncPaginateBaseParams,\n\tUseAsyncPaginateBaseResult,\n} from \"./types\";\n\nexport const increaseStateId = (prevStateId: number): number => prevStateId + 1;\n\nexport const useAsyncPaginateBase = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n\tdeps: ReadonlyArray<unknown> = [],\n): UseAsyncPaginateBaseResult<OptionType, Group> => {\n\tconst {\n\t\tdefaultOptions,\n\t\tloadOptionsOnMenuOpen = true,\n\t\tdebounceTimeout = 0,\n\t\tinputValue,\n\t\tmenuIsOpen,\n\t\tfilterOption = null,\n\t\treduceOptions = defaultReduceOptions,\n\t\tshouldLoadMore = defaultShouldLoadMore,\n\t} = params;\n\n\tconst isMountedRef = useIsMountedRef();\n\tconst reduceOptionsRef = useLatest(reduceOptions);\n\tconst loadOptionsOnMenuOpenRef = useLatest(loadOptionsOnMenuOpen);\n\n\tconst isInitRef = useRef<boolean>(true);\n\tconst paramsRef =\n\t\tuseRef<UseAsyncPaginateBaseParams<OptionType, Group, Additional>>(params);\n\n\tparamsRef.current = params;\n\n\tconst [_stateId, setStateId] = useState(0);\n\n\tconst optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n\n\tconst callRequestOptionsRef = useLatest(\n\t\t(caller: RequestOptionsCallerType) => {\n\t\t\trequestOptions(\n\t\t\t\tcaller,\n\t\t\t\tparamsRef,\n\t\t\t\toptionsCacheRef,\n\t\t\t\tdebounceTimeout,\n\t\t\t\t(reduceState) => {\n\t\t\t\t\toptionsCacheRef.current = reduceState(optionsCacheRef.current);\n\n\t\t\t\t\tif (isMountedRef.current) {\n\t\t\t\t\t\tsetStateId(increaseStateId);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treduceOptionsRef.current,\n\t\t\t\tisMountedRef,\n\t\t\t);\n\t\t},\n\t);\n\n\tconst handleScrolledToBottom = useCallback(() => {\n\t\tconst currentInputValue = paramsRef.current.inputValue;\n\t\tconst currentOptions = optionsCacheRef.current[currentInputValue];\n\n\t\tif (currentOptions) {\n\t\t\tcallRequestOptionsRef.current(\"menu-scroll\");\n\t\t}\n\t}, [callRequestOptionsRef, optionsCacheRef]);\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: `callRequestOptionsRef` is a ref\n\tuseEffect(() => {\n\t\tif (isInitRef.current) {\n\t\t\tisInitRef.current = false;\n\t\t} else {\n\t\t\toptionsCacheRef.current = {};\n\t\t\tsetStateId(increaseStateId);\n\t\t}\n\n\t\tif (defaultOptions === true) {\n\t\t\tcallRequestOptionsRef.current(\"autoload\");\n\t\t}\n\t}, deps);\n\n\tuseEffect(() => {\n\t\tif (menuIsOpen && !optionsCacheRef.current[inputValue]) {\n\t\t\tcallRequestOptionsRef.current(\"input-change\");\n\t\t}\n\t}, [callRequestOptionsRef, inputValue, menuIsOpen, optionsCacheRef]);\n\n\tuseEffect(() => {\n\t\tif (\n\t\t\tmenuIsOpen &&\n\t\t\t!optionsCacheRef.current[\"\"] &&\n\t\t\tloadOptionsOnMenuOpenRef.current\n\t\t) {\n\t\t\tcallRequestOptionsRef.current(\"menu-toggle\");\n\t\t}\n\t}, [\n\t\tcallRequestOptionsRef,\n\t\tloadOptionsOnMenuOpenRef,\n\t\tmenuIsOpen,\n\t\toptionsCacheRef,\n\t]);\n\n\tconst currentOptions: OptionsCacheItem<OptionType, Group, Additional> =\n\t\toptionsCacheRef.current[inputValue] || getInitialCache(params);\n\n\treturn {\n\t\thandleScrolledToBottom,\n\t\tshouldLoadMore,\n\t\tfilterOption,\n\t\tisLoading:\n\t\t\tcurrentOptions.isLoading || currentOptions.lockedUntil > Date.now(),\n\t\tisFirstLoad: currentOptions.isFirstLoad,\n\t\toptions: currentOptions.options,\n\t};\n};\n", "import type { GroupBase, OptionsOrGroups } from \"react-select\";\n\nexport const defaultReduceOptions = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n>(\n\tprevOptions: OptionsOrGroups<OptionType, Group>,\n\tloadedOptions: OptionsOrGroups<OptionType, Group>,\n) => [...prevOptions, ...loadedOptions];\n", "import type { ShouldLoadMore } from \"./types\";\n\nconst AVAILABLE_DELTA = 10;\n\nexport const defaultShouldLoadMore: ShouldLoadMore = (\n\tscrollHeight,\n\tclientHeight,\n\tscrollTop,\n) => {\n\tconst bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n\n\treturn bottomBorder < scrollTop;\n};\n", "import type { GroupBase } from \"react-select\";\nimport type { OptionsCacheItem, UseAsyncPaginateBaseParams } from \"./types\";\n\nexport const getInitialCache = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n): OptionsCacheItem<OptionType, Group, Additional> => ({\n\tisFirstLoad: true,\n\toptions: [],\n\thasMore: true,\n\tisLoading: false,\n\tlockedUntil: 0,\n\tadditional: params.additional,\n});\n", "import type { GroupBase } from \"react-select\";\nimport type { OptionsCache, UseAsyncPaginateBaseParams } from \"./types\";\n\nexport const getInitialOptionsCache = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>({\n\toptions,\n\tdefaultOptions,\n\tadditional,\n\tdefaultAdditional,\n}: UseAsyncPaginateBaseParams<OptionType, Group, Additional>): OptionsCache<\n\tOptionType,\n\tGroup,\n\tAdditional\n> => {\n\tconst initialOptions =\n\t\tdefaultOptions === true\n\t\t\t? null\n\t\t\t: Array.isArray(defaultOptions)\n\t\t\t\t? defaultOptions\n\t\t\t\t: options;\n\n\tif (initialOptions) {\n\t\treturn {\n\t\t\t\"\": {\n\t\t\t\tisFirstLoad: false,\n\t\t\t\tisLoading: false,\n\t\t\t\toptions: initialOptions,\n\t\t\t\thasMore: true,\n\t\t\t\tlockedUntil: 0,\n\t\t\t\tadditional: defaultAdditional || additional,\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {};\n};\n", "import { getResult } from \"krustykrab\";\nimport type { MutableRefObject } from \"react\";\nimport type { GroupBase } from \"react-select\";\nimport sleep from \"sleep-promise\";\nimport { getInitialCache } from \"./getInitialCache\";\nimport type {\n\tOptionsCache,\n\tOptionsCacheItem,\n\tReduceOptions,\n\tRequestOptionsCallerType,\n\tUseAsyncPaginateBaseParams,\n} from \"./types\";\nimport { validateResponse } from \"./validateResponse\";\n\ntype MapOptionsCache<\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n> = (\n\tprevCache: OptionsCache<OptionType, Group, Additional>,\n) => OptionsCache<OptionType, Group, Additional>;\n\ntype SetOptionsCache<\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n> = (stateMapper: MapOptionsCache<OptionType, Group, Additional>) => void;\n\nexport const requestOptions = async <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tcaller: RequestOptionsCallerType,\n\tparamsRef: MutableRefObject<\n\t\tUseAsyncPaginateBaseParams<OptionType, Group, Additional>\n\t>,\n\toptionsCacheRef: MutableRefObject<\n\t\tOptionsCache<OptionType, Group, Additional>\n\t>,\n\tdebounceTimeout: number,\n\tsetOptionsCache: SetOptionsCache<OptionType, Group, Additional>,\n\treduceOptions: ReduceOptions<OptionType, Group, Additional>,\n\tisMountedRef: {\n\t\tcurrent: boolean;\n\t},\n): Promise<void> => {\n\tconst currentInputValue = paramsRef.current.inputValue;\n\n\tconst isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n\n\tconst currentOptions: OptionsCacheItem<OptionType, Group, Additional> =\n\t\tisCacheEmpty\n\t\t\t? getInitialCache(paramsRef.current)\n\t\t\t: optionsCacheRef.current[currentInputValue];\n\n\tif (\n\t\tcurrentOptions.isLoading ||\n\t\t!currentOptions.hasMore ||\n\t\tcurrentOptions.lockedUntil > Date.now()\n\t) {\n\t\treturn;\n\t}\n\n\tsetOptionsCache(\n\t\t(\n\t\t\tprevOptionsCache: OptionsCache<OptionType, Group, Additional>,\n\t\t): OptionsCache<OptionType, Group, Additional> => ({\n\t\t\t...prevOptionsCache,\n\t\t\t[currentInputValue]: {\n\t\t\t\t...currentOptions,\n\t\t\t\tisLoading: true,\n\t\t\t},\n\t\t}),\n\t);\n\n\tif (debounceTimeout > 0 && caller === \"input-change\") {\n\t\tawait sleep(debounceTimeout);\n\n\t\tconst newInputValue = paramsRef.current.inputValue;\n\n\t\tif (currentInputValue !== newInputValue) {\n\t\t\tsetOptionsCache((prevOptionsCache) => {\n\t\t\t\tif (isCacheEmpty) {\n\t\t\t\t\tconst { [currentInputValue]: itemForDelete, ...restCache } =\n\t\t\t\t\t\tprevOptionsCache;\n\n\t\t\t\t\treturn restCache;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...prevOptionsCache,\n\t\t\t\t\t[currentInputValue]: {\n\t\t\t\t\t\t...currentOptions,\n\t\t\t\t\t\tisLoading: false,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst { loadOptions, reloadOnErrorTimeout = 0 } = paramsRef.current;\n\n\tconst result = await getResult(\n\t\tPromise.resolve().then(() =>\n\t\t\tloadOptions(\n\t\t\t\tcurrentInputValue,\n\t\t\t\tcurrentOptions.options,\n\t\t\t\tcurrentOptions.additional,\n\t\t\t),\n\t\t),\n\t);\n\n\tif (!isMountedRef.current) {\n\t\treturn;\n\t}\n\n\tif (result.isErr()) {\n\t\tsetOptionsCache((prevOptionsCache) => ({\n\t\t\t...prevOptionsCache,\n\t\t\t[currentInputValue]: {\n\t\t\t\t...currentOptions,\n\t\t\t\tisLoading: false,\n\t\t\t\tlockedUntil: Date.now() + reloadOnErrorTimeout,\n\t\t\t},\n\t\t}));\n\n\t\treturn;\n\t}\n\n\tconst response = result.unwrap();\n\n\tif (validateResponse(response)) {\n\t\tconst { options, hasMore } = response;\n\n\t\tconst newAdditional = Object.hasOwn(response, \"additional\")\n\t\t\t? response.additional\n\t\t\t: currentOptions.additional;\n\n\t\tsetOptionsCache((prevOptionsCache) => ({\n\t\t\t...prevOptionsCache,\n\t\t\t[currentInputValue]: {\n\t\t\t\t...currentOptions,\n\t\t\t\toptions: reduceOptions(currentOptions.options, options, newAdditional),\n\t\t\t\thasMore: !!hasMore,\n\t\t\t\tisLoading: false,\n\t\t\t\tisFirstLoad: false,\n\t\t\t\tadditional: newAdditional,\n\t\t\t},\n\t\t}));\n\t}\n};\n", "import type { GroupBase } from \"react-select\";\nimport type { Response } from \"./types\";\n\nexport const errorText =\n\t'[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\n\nexport const checkIsResponse = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tresponse: unknown,\n): response is Response<OptionType, Group, Additional> => {\n\tif (!response) {\n\t\treturn false;\n\t}\n\n\tconst { options, hasMore } = response as {\n\t\toptions?: unknown;\n\t\thasMore?: unknown;\n\t};\n\n\tif (!Array.isArray(options)) {\n\t\treturn false;\n\t}\n\n\tif (typeof hasMore !== \"boolean\" && typeof hasMore !== \"undefined\") {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nexport const validateResponse = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tresponse: unknown,\n): response is Response<OptionType, Group, Additional> => {\n\tif (!checkIsResponse(response)) {\n\t\tconsole.error(errorText, \"Received:\", response);\n\t\tthrow new Error(errorText);\n\t}\n\n\treturn true;\n};\n", "import { useMemo } from \"react\";\nimport type { GroupBase, Props as SelectProps } from \"react-select\";\nimport { components as defaultComponents } from \"react-select\";\nimport { wrapMenuList } from \"./wrapMenuList\";\n\nexport const MenuList = wrapMenuList(defaultComponents.MenuList);\n\nexport type SelectComponentsConfig<\n\tOptionType,\n\tIsMulti extends boolean,\n\tGroup extends GroupBase<OptionType>,\n> = Partial<SelectProps<OptionType, IsMulti, Group>[\"components\"]>;\n\nexport const useComponents = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tIsMulti extends boolean,\n>(\n\tcomponents: SelectComponentsConfig<OptionType, IsMulti, Group>,\n): SelectComponentsConfig<OptionType, IsMulti, Group> =>\n\tuseMemo(\n\t\t() => ({\n\t\t\tMenuList,\n\t\t\t...components,\n\t\t}),\n\t\t[components],\n\t);\n", "import composeRefs from \"@seznam/compose-react-refs\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport type { ReactElement } from \"react\";\nimport type { GroupBase, MenuListProps } from \"react-select\";\nimport type { ShouldLoadMore } from \"./types\";\n\nexport const CHECK_TIMEOUT = 300;\n\nexport type BaseSelectProps = {\n\thandleScrolledToBottom?: () => void;\n\tshouldLoadMore: ShouldLoadMore;\n};\n\ntype MenuListType<\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n> = (props: MenuListProps<Option, IsMulti, Group>) => ReactElement;\n\nexport function wrapMenuList<\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n>(MenuList: MenuListType<Option, IsMulti, Group>) {\n\tfunction WrappedMenuList(props: MenuListProps<Option, IsMulti, Group>) {\n\t\tconst { selectProps, innerRef } = props;\n\n\t\tconst { handleScrolledToBottom, shouldLoadMore } =\n\t\t\tselectProps as unknown as BaseSelectProps;\n\n\t\tconst checkTimeoutRef = useRef<NodeJS.Timeout>();\n\t\tconst menuListRef = useRef<HTMLElement>(null);\n\n\t\tconst shouldHandle = useCallback(() => {\n\t\t\tconst el = menuListRef.current;\n\n\t\t\t// menu is not rendered\n\t\t\tif (!el) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst { scrollTop, scrollHeight, clientHeight } = el;\n\n\t\t\treturn shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n\t\t}, [shouldLoadMore]);\n\n\t\tconst checkAndHandle = useCallback(() => {\n\t\t\tif (shouldHandle()) {\n\t\t\t\tif (handleScrolledToBottom) {\n\t\t\t\t\thandleScrolledToBottom();\n\t\t\t\t}\n\t\t\t}\n\t\t}, [shouldHandle, handleScrolledToBottom]);\n\n\t\tconst setCheckAndHandleTimeout = useMemo(() => {\n\t\t\tconst res = () => {\n\t\t\t\tcheckAndHandle();\n\n\t\t\t\tcheckTimeoutRef.current = setTimeout(res, CHECK_TIMEOUT);\n\t\t\t};\n\n\t\t\treturn res;\n\t\t}, [checkAndHandle]);\n\n\t\t// biome-ignore lint/correctness/useExhaustiveDependencies: call only on init\n\t\tuseEffect(() => {\n\t\t\tsetCheckAndHandleTimeout();\n\n\t\t\treturn () => {\n\t\t\t\tif (checkTimeoutRef.current) {\n\t\t\t\t\tclearTimeout(checkTimeoutRef.current);\n\t\t\t\t}\n\t\t\t};\n\t\t}, []);\n\n\t\treturn (\n\t\t\t<MenuList\n\t\t\t\t{...props}\n\t\t\t\tinnerRef={composeRefs<HTMLElement>(innerRef, menuListRef)}\n\t\t\t/>\n\t\t);\n\t}\n\n\treturn WrappedMenuList;\n}\n", "import type { ReactElement, Ref } from \"react\";\nimport type {\n\tGroupBase,\n\tSelectInstance,\n\tProps as SelectProps,\n} from \"react-select\";\nimport type {\n\tAsyncPaginateProps,\n\tUseAsyncPaginateResult,\n\tWithAsyncPaginateType,\n} from \"./types\";\nimport { useAsyncPaginate } from \"./useAsyncPaginate\";\nimport { useComponents } from \"./useComponents\";\n\nconst defaultCacheUniqs: unknown[] = [];\nconst defaultComponents = {};\n\ntype SelectComponentType = <\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n>(\n\tprops: SelectProps<Option, IsMulti, Group> & {\n\t\tref?: Ref<SelectInstance<Option, IsMulti, Group>>;\n\t},\n) => ReactElement;\n\nexport function withAsyncPaginate(\n\tSelectComponent: SelectComponentType,\n): WithAsyncPaginateType {\n\tfunction WithAsyncPaginate<\n\t\tOptionType,\n\t\tGroup extends GroupBase<OptionType>,\n\t\tAdditional,\n\t\tIsMulti extends boolean = false,\n\t>(\n\t\tprops: AsyncPaginateProps<OptionType, Group, Additional, IsMulti>,\n\t): ReactElement {\n\t\tconst {\n\t\t\tcomponents = defaultComponents,\n\t\t\tselectRef = undefined,\n\t\t\tisLoading: isLoadingProp,\n\t\t\tcacheUniqs = defaultCacheUniqs,\n\t\t\t...rest\n\t\t} = props;\n\n\t\tconst asyncPaginateProps: UseAsyncPaginateResult<OptionType, Group> =\n\t\t\tuseAsyncPaginate(rest, cacheUniqs);\n\n\t\tconst processedComponents = useComponents<OptionType, Group, IsMulti>(\n\t\t\tcomponents,\n\t\t);\n\n\t\tconst isLoading =\n\t\t\ttypeof isLoadingProp === \"boolean\"\n\t\t\t\t? isLoadingProp\n\t\t\t\t: asyncPaginateProps.isLoading;\n\n\t\treturn (\n\t\t\t<SelectComponent\n\t\t\t\t{...props}\n\t\t\t\t{...asyncPaginateProps}\n\t\t\t\tisLoading={isLoading}\n\t\t\t\tcomponents={processedComponents}\n\t\t\t\tref={selectRef}\n\t\t\t/>\n\t\t);\n\t}\n\n\treturn WithAsyncPaginate;\n}\n", "import type { GroupBase, OptionsOrGroups } from \"react-select\";\n\nexport const checkGroup = (group: unknown): group is GroupBase<unknown> => {\n\tif (!group) {\n\t\treturn false;\n\t}\n\n\tconst { label, options } = group as {\n\t\tlabel?: unknown;\n\t\toptions?: unknown;\n\t};\n\n\tif (typeof label !== \"string\" && typeof label !== \"undefined\") {\n\t\treturn false;\n\t}\n\n\tif (!Array.isArray(options)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nexport const reduceGroupedOptions = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n>(\n\tprevOptions: OptionsOrGroups<OptionType, Group>,\n\tloadedOptions: OptionsOrGroups<OptionType, Group>,\n): OptionsOrGroups<OptionType, Group> => {\n\tconst res = prevOptions.slice();\n\n\tconst mapLabelToIndex: Record<string, number> = {};\n\tlet prevOptionsIndex = 0;\n\tconst prevOptionsLength = prevOptions.length;\n\n\tfor (const optionOrGroup of loadedOptions) {\n\t\tconst group = checkGroup(optionOrGroup)\n\t\t\t? optionOrGroup\n\t\t\t: ({\n\t\t\t\t\toptions: [optionOrGroup],\n\t\t\t\t} as unknown as Group);\n\n\t\tconst { label = \"\" } = group;\n\n\t\tlet groupIndex = mapLabelToIndex[label];\n\t\tif (typeof groupIndex !== \"number\") {\n\t\t\tfor (\n\t\t\t\t;\n\t\t\t\tprevOptionsIndex < prevOptionsLength &&\n\t\t\t\ttypeof mapLabelToIndex[label] !== \"number\";\n\t\t\t\t++prevOptionsIndex\n\t\t\t) {\n\t\t\t\tconst prevGroup = prevOptions[prevOptionsIndex];\n\n\t\t\t\tif (checkGroup(prevGroup)) {\n\t\t\t\t\tmapLabelToIndex[prevGroup.label || \"\"] = prevOptionsIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroupIndex = mapLabelToIndex[label];\n\t\t}\n\n\t\tif (typeof groupIndex !== \"number\") {\n\t\t\tmapLabelToIndex[label] = res.length;\n\t\t\tres.push(group);\n\t\t} else {\n\t\t\tres[groupIndex] = {\n\t\t\t\t...res[groupIndex],\n\t\t\t\toptions: [...(res[groupIndex] as Group).options, ...group.options],\n\t\t\t};\n\t\t}\n\t}\n\n\treturn res;\n};\n", "import { type MutableRefObject, useRef } from \"react\";\n\nexport const EMPTY_VALUE = Symbol(\"useLazyRef empty value\");\n\nexport const useLazyRef = <T>(init: () => T): MutableRefObject<T> => {\n\tconst resultRef = useRef<T | typeof EMPTY_VALUE>(EMPTY_VALUE);\n\n\tif (resultRef.current === EMPTY_VALUE) {\n\t\tresultRef.current = init();\n\t}\n\n\treturn resultRef as MutableRefObject<T>;\n};\n", "import { useRef, useEffect } from 'react';\n\nfunction useIsMountedRef(): { readonly current: boolean } {\n  const isMountedRef = useRef(false);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  return isMountedRef;\n}\n\nexport default useIsMountedRef;\n", "import * as React from 'react';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\n\nvar useLatest = function useLatest(value) {\n  var ref = React.useRef(value);\n  useIsomorphicLayoutEffect(function () {\n    ref.current = value;\n  });\n  return ref;\n};\n\nexport { useLatest as default };\n", "/**\n * An implementation of `Result` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html\n */\nexport type Result<R, E> = Readonly<{\n\t/**\n\t * ```ts\n\t * Ok('foo').isOk(); // returns `true`\n\t * Err('foo').isOk(); // returns `false`\n\t * ```\n\t */\n\tisOk: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isOkAnd((value) => value > 100); // returns `true`\n\t * Ok(12).isOkAnd((value) => value > 100); // returns `false`\n\t * Err(123).isOkAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisOkAnd: (fn: (arg: R) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').isErr(); // returns `false`\n\t * Err('foo').isErr(); // returns `true`\n\t * ```\n\t */\n\tisErr: () => boolean;\n\t/**\n\t * ```ts\n\t * Ok(123).isErrAnd((value) => value > 100); // returns `false`\n\t * Err(123).isErrAnd((value) => value > 100); // returns `true`\n\t * Err(12).isErrAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisErrAnd: (fn: (arg: E) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Ok('foo').ok(); // returns `Some('foo')`\n\t * Err('foo').ok(); // returns `None()`\n\t * ```\n\t */\n\tok: () => Option<R>;\n\t/**\n\t * ```ts\n\t * Ok('foo').err(); // returns `None()`\n\t * Err('foo').err(); // returns `Some('foo')`\n\t * ```\n\t */\n\terr: () => Option<E>;\n\t/**\n\t * ```ts\n\t * Ok(1).map((value) => value * 2); // returns `Ok(2)`\n\t * Err(1).map((value) => value * 2); // returns `Err(1)`\n\t * ```\n\t */\n\tmap: <U>(fn: (arg: R) => U) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOr(10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOr(10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOr: <U>(defaultValue: U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `2`\n\t * Err(1).mapOrElse((err) => err * 10, (value) => value * 2); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <U>(getDefaultValue: (arg: E) => U, fn: (arg: R) => U) => U;\n\t/**\n\t * ```ts\n\t * Ok(1).mapErr((err) => err * 2); // returns `Ok(1)`\n\t * Err(1).mapErr((err) => err * 2); // returns `Err(2)`\n\t * ```\n\t */\n\tmapErr: <F>(fn: (arg: E) => F) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok('foo').expect('error message'); // returns `'foo'`\n\t * Err('foo').expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').expectErr('error message'); // throws `new Error('error message')`\n\t * Err('foo').expectErr('error message'); // returns `'foo'`\n\t * ```\n\t */\n\texpectErr: (msg: string) => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrap(); // returns `'foo'`\n\t * Err('foo').unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapErr(); // throws\n\t * Err('foo').unwrapErr(); // returns `'foo'`\n\t * ```\n\t */\n\tunwrapErr: () => E;\n\t/**\n\t * ```ts\n\t * Ok('foo').unwrapOr('bar'); // returns `'foo'`\n\t * Err('foo').unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: R) => R;\n\t/**\n\t * ```ts\n\t * Ok(1).unwrapOrElse('bar'); // returns `1`\n\t * Err(1).unwrapOrElse((err) => err * 2); // returns `2`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: (arg: E) => R) => R;\n\t/**\n\t * ```ts\n\t * Ok('foo').and(otherResult); // returns `otherResult`\n\t * Err('foo').and(otherResult); // returns `Err('foo')`\n\t * ```\n\t */\n\tand: <U>(res: Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok(1).andThen((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Ok(1).andThen((value) => Err(value * 2)); // returns `Err(2)`\n\t * Err(1).andThen((value) => Ok(value * 2)); // returns `Err(1)`\n\t * ```\n\t */\n\tandThen: <U>(getRes: (arg: R) => Result<U, E>) => Result<U, E>;\n\t/**\n\t * ```ts\n\t * Ok('foo').or(otherResult); // returns `Ok('foo').`\n\t * Err('foo').or(otherResult); // returns `otherResult`\n\t * ```\n\t */\n\tor: <F>(res: Result<R, F>) => Result<R, F>;\n\t/**\n\t * ```ts\n\t * Ok(1).orElse((value) => Ok(value * 2)); // returns `Ok(1)`\n\t * Err(1).orElse((value) => Ok(value * 2)); // returns `Ok(2)`\n\t * Err(1).orElse((value) => Err(value * 2)); // returns `Err(2)`\n\t * ```\n\t */\n\torElse: <F>(getRes: (arg: E) => Result<R, F>) => Result<R, F>;\n}>;\n\n/**\n * @param result The success value\n * @returns The success result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok\n */\nexport function Ok<R, E>(result: R): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => true,\n\t\tisOkAnd: (fn) => fn(result),\n\t\tisErr: () => false,\n\t\tisErrAnd: () => false,\n\t\tok: () => Some(result),\n\t\terr: () => None(),\n\t\tmap: (fn) => Ok(fn(result)),\n\t\tmapOr: (_, fn) => fn(result),\n\t\tmapOrElse: (_, fn) => fn(result),\n\t\tmapErr: () => Ok(result),\n\t\texpect: () => result,\n\t\texpectErr: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tunwrap: () => result,\n\t\tunwrapErr: () => {\n\t\t\tthrow new Error(`${result}`);\n\t\t},\n\t\tunwrapOr: () => result,\n\t\tunwrapOrElse: () => result,\n\t\tand: (res) => res,\n\t\tandThen: (getRes) => getRes(result),\n\t\tor: () => Ok(result),\n\t\torElse: () => Ok(result),\n\t};\n\n\treturn self;\n}\n\n/**\n * @param err The error value\n * @returns The error result\n *\n * https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\n */\nexport function Err<R, E>(err: E): Result<R, E> {\n\tconst self: Result<R, E> = {\n\t\tisOk: () => false,\n\t\tisOkAnd: () => false,\n\t\tisErr: () => true,\n\t\tisErrAnd: (fn) => fn(err),\n\t\tok: () => None(),\n\t\terr: () => Some(err),\n\t\tmap: () => Err(err),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tmapErr: (fn) => Err(fn(err)),\n\t\texpect: (msg) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\texpectErr: () => err,\n\t\tunwrap: () => {\n\t\t\tthrow new Error(`${err}`);\n\t\t},\n\t\tunwrapErr: () => err,\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(err),\n\t\tand: () => Err(err),\n\t\tandThen: () => Err(err),\n\t\tor: (res) => res,\n\t\torElse: (getRes) => getRes(err),\n\t};\n\n\treturn self;\n}\n\n/**\n * An implementation of `Option` from Rust stdlib\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html\n */\nexport type Option<T> = Readonly<{\n\t/**\n\t * ```ts\n\t * Some('foo').and(otherOption); // returns `otherOption`\n\t * None().and(otherOption); // returns `None()`\n\t * ```\n\t */\n\tand: <R>(opt: Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).andThen((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().andThen((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tandThen: <R>(fn: (arg: T) => Option<R>) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some('foo').expect('error message'); // returns `'foo'`\n\t * None().expect('error message'); // throws `new Error('error message')`\n\t * ```\n\t */\n\texpect: (msg: string) => T;\n\t/**\n\t * ```ts\n\t * Some(123).filter((value) => value > 100); // returns `Some(123)`\n\t * Some(12).filter((value) => value > 100); // returns `None()`\n\t * None().filter((value) => value > 100); // returns `None()`\n\t * ```\n\t */\n\tfilter: (fn: (arg: T) => boolean) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').isSome(); // returns `true`\n\t * None().isSome(); // returns `false`\n\t * ```\n\t */\n\tisSome: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(123).isSomeAnd((value) => value > 100); // returns `true`\n\t * Some(12).isSomeAnd((value) => value > 100); // returns `false`\n\t * None().isSomeAnd((value) => value > 100); // returns `false`\n\t * ```\n\t */\n\tisSomeAnd: (fn: (arg: T) => boolean) => boolean;\n\t/**\n\t * ```ts\n\t * Some('foo').isNone(); // returns `false`\n\t * None().isNone(); // returns `true`\n\t * ```\n\t */\n\tisNone: () => boolean;\n\t/**\n\t * ```ts\n\t * Some(1).map((value) => Some(value * 2)); // returns `Some(2)`\n\t * None().map((value) => Some(value * 2)); // returns `None()`\n\t * ```\n\t */\n\tmap: <R>(fn: (arg: T) => R) => Option<R>;\n\t/**\n\t * ```ts\n\t * Some(1).mapOr(10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOr(10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOr: <R>(defaultValue: R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some(1).mapOrElse(() => 10, (value) => Some(value * 2)); // returns `2`\n\t * None().mapOrElse(() => 10, (value) => Some(value * 2)); // returns `10`\n\t * ```\n\t */\n\tmapOrElse: <R>(getDefaultValue: () => R, fn: (arg: T) => R) => R;\n\t/**\n\t * ```ts\n\t * Some('foo').okOr('err'); // returns `Ok('foo')`\n\t * None().okOr('err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOr: <E>(err: E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').okOrElse(() => 'err'); // returns `Ok('foo')`\n\t * None().okOrElse(() => 'err'); // returns `Err('err')`\n\t * ```\n\t */\n\tokOrElse: <E>(getErr: () => E) => Result<T, E>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(otherOption); // returns `Some('foo')`\n\t * None().or(otherOption); // returns `otherOption`\n\t * ```\n\t */\n\tor: (opt: Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').or(() => Some('bar')); // returns `Some('foo')`\n\t * None().or(() => Some('bar')); // returns `Some('bar')`\n\t * None().or(() => None()); // returns `None()`\n\t * ```\n\t */\n\torElse: (fn: () => Option<T>) => Option<T>;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrap(); // returns `'foo'`\n\t * None().unwrap(); // throws\n\t * ```\n\t */\n\tunwrap: () => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOr('bar'); // returns `'foo'`\n\t * None().unwrapOr('bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOr: (defaultValue: T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').unwrapOrElse(() => 'bar'); // returns `'foo'`\n\t * None().unwrapOrElse(() => 'bar'); // returns `'bar'`\n\t * ```\n\t */\n\tunwrapOrElse: (getDefaultValue: () => T) => T;\n\t/**\n\t * ```ts\n\t * Some('foo').xor(Some('bar')); // returns `None()`\n\t * Some('foo').xor(None()); // returns `Some('foo')`\n\t * None().xor(Some('bar')); // returns `Some('bar')`\n\t * None().xor(None()); // returns `None()`\n\t * ```\n\t */\n\txor: (opt: Option<T>) => Option<T>;\n}>;\n\n/**\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n *\n * @returns Empty option\n */\nexport function None<T>(): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: () => None(),\n\t\tandThen: () => None(),\n\t\texpect: (msg: string) => {\n\t\t\tthrow new Error(msg);\n\t\t},\n\t\tfilter: () => self,\n\t\tisSome: () => false,\n\t\tisSomeAnd: () => false,\n\t\tisNone: () => true,\n\t\tmap: () => None(),\n\t\tmapOr: (defaultValue) => defaultValue,\n\t\tmapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\tokOr: (err) => Err(err),\n\t\tokOrElse: (getErr) => Err(getErr()),\n\t\tor: (opt) => opt,\n\t\torElse: (fn) => fn(),\n\t\tunwrap: () => {\n\t\t\tthrow new Error(\"panic! call `unwrap` on a `None` value\");\n\t\t},\n\t\tunwrapOr: (defaultValue) => defaultValue,\n\t\tunwrapOrElse: (getDefaultValue) => getDefaultValue(),\n\t\txor: (opt) => {\n\t\t\tif (opt.isSome()) {\n\t\t\t\treturn opt;\n\t\t\t}\n\n\t\t\treturn self;\n\t\t},\n\t};\n\n\treturn self;\n}\n\n/**\n * @param value Some value\n * @returns Filled option\n *\n * https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n */\nexport function Some<T>(value: T): Option<T> {\n\tconst self: Option<T> = {\n\t\tand: (opt) => opt,\n\t\tandThen: (fn) => fn(value),\n\t\texpect: () => value,\n\t\tfilter: (fn) => {\n\t\t\tif (fn(value)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t\tisSome: () => true,\n\t\tisSomeAnd: (fn) => fn(value),\n\t\tisNone: () => false,\n\t\tmap: (fn) => Some(fn(value)),\n\t\tmapOr: (_, fn) => fn(value),\n\t\tmapOrElse: (_, fn) => fn(value),\n\t\tokOr: () => Ok(value),\n\t\tokOrElse: () => Ok(value),\n\t\tor: () => self,\n\t\torElse: () => self,\n\t\tunwrap: () => value,\n\t\tunwrapOr: () => value,\n\t\tunwrapOrElse: () => value,\n\t\txor: (opt) => {\n\t\t\tif (opt.isNone()) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\treturn None();\n\t\t},\n\t};\n\n\treturn self;\n}\n", "import { None, type Option, Some } from \"./option_result\";\n\n/**\n * Convert a nullable variable to `Option`\n * @param arg nullable variable\n * @returns Option\n *\n * ```\n * const option = toOption('foo');\n * option.isNone(); // returns `false`;\n * option.unwrap(); // returns `'foo'`;\n *\n * toOption(null).isNone(); // returns `true`\n * toOption(undefined).isNone(); // returns `true`\n * ```\n */\nexport function toOption<T>(arg: T | null | undefined): Option<T> {\n\tif (arg === null || arg === undefined) {\n\t\treturn None();\n\t}\n\n\treturn Some<T>(arg);\n}\n", "import { Err, Ok, type Result } from \"./option_result\";\n\n/**\n * Converts `Promise` to `Result`\n * @param promise target `Promise`\n * @returns success result for resolved promise or error result for rejected promise\n *\n * ```ts\n * const successResult = await getResult(Promise.resolve('foo'));\n * successResult.unwrap(); // returns 'foo'\n *\n * const errorResult = await getResult(Promise.reject('bar'));\n * errorResult.unwrapErr(); // returns 'bar'\n * ```\n */\nexport function getResult<R, E>(promise: Promise<R>): Promise<Result<R, E>> {\n\treturn promise.then(\n\t\t(response) => Ok(response),\n\t\t(err) => Err(err),\n\t);\n}\n", "/**\n * Panics if the value is `null` or `undefined` or returns it otherwise\n * @param value Target value\n * @returns Unchanged value\n * @throws If the value is `null` or `undefined`\n *\n * ```ts\n * const fooOrUndefined = document.getElementById('foo'); // html element or `undefined`\n * const foo = unwrap(fooOrUndefined); // exactly html element\n * ```\n */\nexport function unwrap<T>(value: T | null | undefined): T {\n\tif (value === null || value === undefined) {\n\t\tthrow new Error(`panic! call \\`unwrap\\` on a \\`${value}\\` value`);\n\t}\n\n\treturn value;\n}\n", "/**\n * Returns the value if it's not `null` or `undefined`, or returns the default value\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the default value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOr(foo.bar, 'qux'); // returns 'baz'\n * unwrapOr(foo.bat, 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOr<T>(value: T | null | undefined, defaultValue: T): T {\n\tif (value === null || value === undefined) {\n\t\treturn defaultValue;\n\t}\n\n\treturn value;\n}\n", "/**\n * Returns the value if it's not `null` or `undefined`, or computes it\n * @param value Target value\n * @returns Unchanged value if it's not `null` or `undefined` or the computed value\n *\n * ```ts\n * const foo: Partial<Record<string, string>> = { bar: 'baz' };\n *\n * unwrapOrElse(foo.bar, () => 'qux'); // returns 'baz'\n * unwrapOrElse(foo.bat, () => 'qux'); // returns 'qux'\n * ```\n */\nexport function unwrapOrElse<T>(\n\tvalue: T | null | undefined,\n\tgetDefaultValue: () => T,\n): T {\n\tif (value === null || value === undefined) {\n\t\treturn getDefaultValue();\n\t}\n\n\treturn value;\n}\n", "import { Err, Ok, type Result } from \"./option_result\";\n\n/**\n * Wrap the result of a function call with `Result`\n *\n * @param fn target function\n *\n * ```ts\n * const successResult = tryCatch(() => JSON.parse('{\"foo\": \"bar\"}'));\n * successResult.unwrap(); // returns `{ foo: \"bar\" }`\n *\n * const errorResult = tryCatch(() => JSON.parse('{invalid json}'));\n * errorResult.isErr(); // returns `true`\n * ```\n */\nexport function tryCatch<R, E>(fn: () => R): Result<R, E> {\n\tlet result: R;\n\n\ttry {\n\t\tresult = fn();\n\t} catch (e) {\n\t\treturn Err(e as E);\n\t}\n\n\treturn Ok(result);\n}\n", "var e=setTimeout;function t(t,n){var u=n.useCachedSetTimeout?e:setTimeout;return new Promise((function(e){u(e,t)}))}function n(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},u=n.useCachedSetTimeout,r=t(e,{useCachedSetTimeout:u});function o(e){return r.then((function(){return e}))}return o.then=function(){return r.then.apply(r,arguments)},o.catch=Promise.resolve().catch,o}export default n;\n"],
  "mappings": "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",
  "names": ["composeRefs", "import_react", "import_react", "useLatest", "t", "n", "e", "import_react", "import_react", "import_jsx_runtime", "currentOptions", "useState", "useCallback", "MenuList", "useRef", "useEffect", "composeRefs", "components", "useMemo", "defaultComponents", "jsx"]
}
